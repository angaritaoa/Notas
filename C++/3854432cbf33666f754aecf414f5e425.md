# Diseño de clases basado en políticas

- [Diseño de clases basado en políticas](#dise%c3%b1o-de-clases-basado-en-pol%c3%adticas)
	- [La multiplicidad del diseño de software](#la-multiplicidad-del-dise%c3%b1o-de-software)
	- [La falla de la interfaz Todo-en-Uno](#la-falla-de-la-interfaz-todo-en-uno)
	- [El beneficio de las plantillas](#el-beneficio-de-las-plantillas)
	- [Políticas y clases de políticas](#pol%c3%adticas-y-clases-de-pol%c3%adticas)
		- [Implementación de clases de políticas con parámetros de plantilla](#implementaci%c3%b3n-de-clases-de-pol%c3%adticas-con-par%c3%a1metros-de-plantilla)
		- [Implementación de clases de políticas con funciones miembro de plantilla](#implementaci%c3%b3n-de-clases-de-pol%c3%adticas-con-funciones-miembro-de-plantilla)
	- [Políticas enriquecidas](#pol%c3%adticas-enriquecidas)
	- [Destructores de clases de política](#destructores-de-clases-de-pol%c3%adtica)
	- [Funcionalidad opcional a través de instanciación incompleta](#funcionalidad-opcional-a-trav%c3%a9s-de-instanciaci%c3%b3n-incompleta)
	- [Combinando clases de política](#combinando-clases-de-pol%c3%adtica)
	- [Personalizar la estructura con clases de política](#personalizar-la-estructura-con-clases-de-pol%c3%adtica)
	- [Políticas compatibles e incompatibles](#pol%c3%adticas-compatibles-e-incompatibles)
	- [Descomponer una clase en políticas](#descomponer-una-clase-en-pol%c3%adticas)
	- [Resumen](#resumen)

---

Este capítulo describe políticas y clases de políticas, técnicas importantes de diseño de clases que permiten la creación de bibliotecas flexibles y altamente reutilizables. En resumen, el diseño de clases basado en políticas fomenta el ensamblaje de una clase con un comportamiento complejo de muchas clases pequeñas llamadas políticas, cada una de las cuales se ocupa de un solo aspecto de comportamiento o estructural. Una política establece una interfaz relacionada con un problema específico.  Puede implementar políticas de varias maneras siempre que respete la interfaz de políticas.

Debido a que puede mezclar y combinar políticas, puede lograr un conjunto combinatorio de comportamientos mediante el uso de un pequeño núcleo de componentes elementales.

Este capítulo explica el problema que las políticas están destinadas a resolver, proporciona detalles del diseño de clases basadas en políticas y brinda consejos sobre cómo descomponer una clase en políticas.

## La multiplicidad del diseño de software

La ingeniería de software, tal vez más que cualquier otra disciplina de ingeniería, exhibe una rica multiplicidad: puede hacer lo mismo de muchas maneras correctas, y hay infinitos matices entre lo correcto y lo incorrecto. Cada camino abre un nuevo mundo.  Una vez que elige una solución, aparece una gran cantidad de posibles variantes, en todos los niveles, desde el nivel de la arquitectura del sistema hasta el más mínimo detalle de codificación.  El diseño de un sistema de software es una elección de soluciones de un espacio de solución combinatoria.

Pensemos en un artefacto de diseño simple de bajo nivel: un puntero inteligente. Una clase de puntero inteligente puede ser de un solo subproceso o multiproceso, puede usar varias estrategias de propiedad, puede hacer varias compensaciones entre seguridad y velocidad, y puede no admitir conversiones automáticas al tipo de puntero sin procesar el subyacente.  Todas las características se pueden combinar libremente y, por lo general, exactamente una solución es la más adecuada para un área determinada de su aplicación.

La multiplicidad del espacio de diseño confunde constantemente a los diseñadores aprendices. Dado un problema de diseño de software, ¿cuál es una buena solución? ¿Eventos? ¿Objetos? ¿Observadores? ¿Devoluciones de llamada? ¿Virtuales? ¿Plantillas? Hasta una cierta escala y nivel de detalle, muchas soluciones diferentes parecen funcionar igualmente bien.

La diferencia más importante entre un arquitecto de software experto y un principiante es *el conocimiento de lo que funciona y lo que no*. Para cualquier problema arquitectónico dado, hay muchas formas competitivas de resolverlo. Sin embargo, escalan de manera diferente y tienen distintos conjuntos de ventajas y desventajas, que pueden o no ser adecuadas para el problema en cuestión. Una solución que parece ser aceptable en la pizarra podría ser inutilizable en la práctica.

Diseñar sistemas de software es difícil porque constantemente le pide que *elija*. Y en el diseño de programas, al igual que en la vida, la elección es difícil.

Los buenos diseñadores experimentados saben qué opciones llevarán a un buen diseño. Para un principiante, cada elección de diseño abre una puerta a lo desconocido. El diseñador experimentado es como un buen jugador de ajedrez: puede ver más movimientos por delante. Esto lleva tiempo para aprender. Tal vez esta es la razón por la cual el genio de la programación puede mostrarse a una edad temprana, mientras que el genio del diseño de software tiende a tomar más tiempo para madurar.

Además de ser un rompecabezas para principiantes, la naturaleza combinatoria de las decisiones de diseño es una fuente importante de problemas para los escritores de bibliotecas. Para implementar una biblioteca útil de diseños, el diseñador de la biblioteca debe clasificar y acomodar muchas situaciones típicas, y aún así dejar la biblioteca abierta para que el programador de la aplicación pueda adaptarla a las necesidades específicas de una situación particular.

De hecho, ¿cómo se pueden empaquetar componentes de diseño de sonido flexibles en bibliotecas? ¿Cómo se puede dejar que el usuario configure estos componentes? ¿Cómo se combate la "multiplicidad malvada" del diseño con un ejército de código de tamaño razonable? Estas son las preguntas que el resto de este capítulo y, en última instancia, todo este libro, intenta responder.

## La falla de la interfaz Todo-en-Uno

Implementar todo bajo el mismo paraguas de una interfaz para hacer todo no es una buena solución, por varias razones.

Algunas consecuencias negativas importantes son la sobrecarga intelectual, el gran tamaño y la ineficiencia. Las clases gigantescas no tienen éxito porque incurren en una gran sobrecarga de aprendizaje, tienden a ser innecesariamente grandes y conducen a un código que es mucho más lento que la versión artesanal equivalente.

Pero quizás el problema más importante de una interfaz demasiado rica es la perdida de seguridad de tipo estático. Un propósito esencial de la arquitectura de un sistema es hacer cumplir ciertos axiomas **por diseño**, por ejemplo, no puede crear dos objetos `Singleton` o crear objetos de familias disjuntas. Idealmente, un diseño debería imponer la mayoría de las restricciones en tiempo de compilación.

En una interfaz grande que lo abarca todo, es muy difícil hacer cumplir tales restricciones. Normalmente, una vez que ha elegido un cierto conjunto de restricciones de diseño, solo ciertos subconjuntos de la interfaz grande permanecen semánticamente válidos. Crece una brecha entre los usos sintácticamente válidos y semánticamente válidos de la biblioteca. El programador puede escribir un número creciente de construcciones que son sintácticamente válidas, pero semánticamente ilegales.

Los diseños imponen **restricciones**; en consecuencia, las bibliotecas orientadas al diseño deben ayudar a los diseños creados por el usuario a imponer sus propias restricciones predefinidas.

## El beneficio de las plantillas

Las plantillas son un buen candidato para hacer frente a los comportamientos combinatorios porque generan código en tiempo de compilación en función de los tipos proporcionados por el usuario.

Las plantillas de clase se pueden personalizar de formas que no son compatibles con las clases regulares. Si desea implementar un caso especial, puede especializar cualquier función miembro de una plantilla de clase para una instanciación específica de la plantilla de clase. Por ejemplo, si la plantilla es `SmartPtr<T>`, puede especializar cualquier función miembro para, por ejemplo, `SmartPtr<Widget>`. Esto le brinda una buena granularidad en el comportamiento de personalización.

Además, para las plantillas de clase con múltiples parámetros, puede usar la especialización de plantilla parcial. La especialización de plantilla parcial le brinda la capacidad de especializar una plantilla de clase solo para algunos de sus argumentos. Por ejemplo, dada la definición:

```cpp
template <class T, class U> class SmartPtr { ... };
```

puede especializarse `SmartPtr<T, U>` para `Widget` y cualquier otro tipo utilizando la siguiente sintaxis:

```cpp
template <class U> class SmartPtr<Widget, U> { ... };
```

En tiempo de compilación y la naturaleza combinatoria de las plantillas las hacen muy atractivas para crear piezas de diseño. Tan pronto como intente implementar tales diseños,  se topará con varios problemas que no son evidentes:

1. *No puedes especializar la estructura*. Usando solo plantillas, no puede especializar la estructura de una clase (sus miembros de datos). Solo puedes especializar funciones.

1. *La especialización de las funciones miembros no se escala*. Puede especializar cualquier función miembro de una plantilla de clase con un parámetro de plantilla, pero no puede especializar funciones miembro individuales para plantillas con múltiples parámetros de plantilla.

	```cpp
	template <class T> class Widget {
		void Fun() { .. generic implementation ... }
	};
	// OK: specialization of a member function of Widget
	template <> Widget<char>::Fun() {
		... specialized implementation ...
	}
	template <class T, class U> class Gadget {
		void Fun() { .. generic implementation ... }
	};
	// Error! Cannot partially specialize a member class of Gadget
	template <class U> void Gadget<char, U>::Fun() {
		... specialized implementation ...
	}
	```

1. *El escritor de la biblioteca no puede proporcionar múltiples valores predeterminados*. En el mejor de los casos, un implementador de plantilla de clase puede proporcionar una implementación predeterminada única para cada función miembro. No puede proporcionar varios valores predeterminado para una función miembro de plantilla.

Ahora compare la lista de inconvenientes de herencia múltiple con la lista de inconvenientes de plantilla. Curiosamente, la herencia múltiple y las plantillas fomentan compensaciones complementarias. La herencia múltiple pierde información de tipo, que abunda en plantillas. La especialización de plantillas no escala, pero la herencia múltiple escala bastante bien. Puede proporcionar solo un valor predeterminado para la función miembro de plantilla, pero puede escribir un número ilimitado de clases base.

Este análisis sugiere que una combinación de plantillas y herencia múltiple podría generar un mecanismo muy flexible, apropiado para crear bibliotecas de elementos de diseño.

## Políticas y clases de políticas

Las políticas y clases de políticas ayudan a implementar elementos de diseño seguros, eficientes y altamente personalizables. Una política define una interfaz de clase o una interfaz de plantilla de clase. La interfaz consta de uno o todo lo siguiente: definiciones de tipo interno, funciones miembro y variables miembro.

Las políticas tienen mucho en común con los rasgos (Alexandrescu 2000a) pero difieren en que ponen menos énfasis en el tipo y más énfasis en el comportamiento. Además, las políticas recuerdan el patrón de diseño Estrategia (Gamma et al. 1995), con la diferencia de que las políticas están limitadas en tiempo de compilación.

Por ejemplo, definamos una política para crear objetos. La política `Creator` prescribe una plantilla de clase de tipo `T`. Esta plantilla de clase debe exponer una función miembro llamada `Create` que no recibe argumentos y devuelve un puntero a `T`. Semánticamente, cada llamada a `Create` debe devolver un puntero a un nuevo objeto de tipo `T`. El modo exacto en el que se crea el objeto se deja a la latitud de la implementación de la política.

Definamos algunas clases de políticas que implementan la política `Creator`. Una forma posible es usar el operador `new`. Otra forma es usar `malloc` y una llamada al nuevo operador de colocación (Meyers 1998b). Otra forma sería crear objetos clonando un objeto prototipo. Aquí hay ejemplos de los tres métodos:

```cpp
template <class T>
struct OpNewCreator {
	static T* Create() {
		return new T;
	}
};

template <class T>
struct MallocCreator {
	static T* Create() {
		void* buf = std::malloc(sizeof(T));
		if (!buf) return 0;
		return new(buf) T;
	}
};

template <class T>
struct PrototypeCreator {
	PrototypeCreator(T* pObj = 0) : pPrototype_(pObj) {}
	T* Create()	{
		return pPrototype_ ? pPrototype_->Clone() : 0;
	}
	T* GetPrototype() { return pPrototype_; }
	void SetPrototype(T* pObj) { pPrototype_ = pObj; }
private:
	T* pPrototype_;
};
```

Para una política dada, puede haber un número ilimitado de implementaciones. Las implementaciones de una política se denominan *clases de políticas*. Las clases de políticas no están destinadas a un uso independiente; en cambio, son heredadas o contenidas dentro de otras clases.

Un aspecto importante es que, a diferencia de las interfaces clásicas (colecciones de funciones virtuales puras), las interfaces de las políticas están poco definidas. Las políticas están orientadas a la sintaxis, no a la firma. En otras palabras, `Creator` especifica que construcciones sintácticas deberían ser válidas para una clase conforme, en lugar de que funciones exactas deben implementar esa clase. Por ejemplo, la política `Creator` no especifica que `Create` debe ser estático o virtual; el único requisito es que la plantilla de clase defina una función miembro `Create`. Además, `Creator` dice que `Create` debería devolver un puntero a un nuevo objeto. En consecuencia, es aceptable que, en casos especiales, `Create` devuelva cero o arroje una excepción.

Puede implementar varias clases de políticas para una política determinada. Todos deben respetar la interfaz definida por la política. El usuario luego elige que clase de política usar en estructuras más grandes, como verá.

Las tres clases de políticas definidas anteriormente tienen implementaciones diferentes e incluso interfaces ligeramente diferentes (por ejemplo, `PrototypeCreator` tiene dos funciones adicionales: ` GetPrototype` y `SetPrototype`). Sin embargo, todos definen una función llamada `Create` con el tipo de retorno requerido, por lo que se ajustan a la política de `Creator`.

Veamos ahora como podemos diseñar una clase que explote la política `Creator`. Dicha clase contendrá o heredará una de las tres clases definidas anteriormente, como se muestra a continuación:

```cpp
// Library code
template <class CreationPolicy>
class WidgetManager : public CreationPolicy {
	...
};
```

Las clases que usan una o más políticas se denominan *host* o *clases de host*. En el ejemplo anterior, `WidgetManager` es una clase de host con una política. Los anfitriones son responsables de ensamblar las estructuras y comportamientos de sus políticas en una sola unidad compleja.

> Aunque las clases de host son técnicamente plantillas de clase de host, mantengamos una definición única. Tanto las clases de host como las plantillas de clase de host tienen el mismo concepto.

Al crear instancias de la plantilla `WidgetManager`, el cliente pasa la política deseada:

```cpp
// Application code
typedef WidgetManager< OpNewCreator<Widget> > MyWidgetMgr;
```

Analicemos el contexto resultante. Siempre que un objeto de tipo `MyWidgetMgr` necesita crear un `Widget`, invoca `Create()` para su subobjeto de política `OpNewCreator<Widget>`. Sin embargo, es el usuario de `MyWidgetMgr` quien elige la política de creación. Efectivamente, a través de su diseño, `MyWidgetMgr` permite a sus usuarios configurar un aspecto especifico de la funcionalidad de `MyWidgetMgr`.

Esta es la esencia del diseño de clases basado en políticas.

### Implementación de clases de políticas con parámetros de plantilla

A menudo, como es el caso anterior, el argumento de plantilla de la política es redundante. Es incómodo que el usuario deba pasar el argumento de la plantilla `OpNewCreator` explícitamente. Normalmente, la clase de host ya conoce, o puede deducir fácilmente, el argumento de plantilla de la clase de política. En el ejemplo anterior, `MyWidgetMgr` siempre maneja objetos de tipo `Widget`, por lo que requerir que el usuario especifique `Widget` nuevamente en la instancia de `OpNewCreator` es redundante y potencialmente peligroso.

En este caso, el código de la biblioteca puede usar parámetros de plantilla de plantilla para especificar políticas, como se muestra a continuación:

```cpp
// Library code
template <template <class Created> class CreationPolicy>
class WidgetManager : public CreationPolicy<Widget> {
	...
};
```

A pesar de las apariencias, el símbolo `Created` no contribuye a la definición de `WidgetManager`. No puede usar `Created` dentro de `WidgetManager`: es un argumento formal para `CreationPolicy` y simplemente puede omitirse.

El código de la aplicación ahora solo necesita proporcionar el nombre de la plantilla al crear una instancia de `WidgetManager`:

```cpp
// Application code
typedef WidgetManager<OpNewCreator> MyWidgetMgr;
```

Usar parámetros de plantilla de plantilla con clases de políticas no es simplemente una cuestión de conveniencia; a veces, es esencial que la clase de host tenga acceso a la plantilla para que el host pueda instanciar con un tipo diferente. Por ejemplo, suponga que `WidgetManager` también necesita crear objetos de tipo `Gadget` usando la misma política de creación. Entonces el código se vería así:

```cpp
// Library code
template <template <class> class CreationPolicy>
class WidgetManager : public CreationPolicy<Widget> {
	...
	void DoSomething()	{
		Gadget* pW = CreationPolicy<Gadget>().Create();
		...
	}
};
```

### Implementación de clases de políticas con funciones miembro de plantilla

Una alternativa al uso de parámetros de plantilla de plantilla es usar funciones de miembro de plantilla junto con clases simples. Es decir, la implementación de la política es una clase simple (a diferencia de una clase de plantilla) pero tiene uno o más miembros con plantilla.

Por ejemplo, podemos redefinir la política `Creator` para prescribir una clase regular (sin plantilla) que exponga una función de plantilla `Create<T>`. Una clase de política conforme tiene el siguiente aspecto:

```cpp
struct OpNewCreator {
	template <class T>
	static T* Create() {
		return new T;
	}
};
```

Esta forma de definir e implementar una política tiene la ventaja de estar mejor respaldada por compiladores más antiguos. Por otro lado, las políticas definidas de esta manera son a menudo más difíciles de hablar, definir, implementar y usar.

## Políticas enriquecidas

La política `Creator` prescribe solo una función miembro, `Create`. Sin embargo, `PrototypeCreator` define dos funciones más: `GetPrototype` y `SetPrototype`. Analicemos el contexto resultante.

Debido a que `WidgetManager` hereda su clase de política y a que `GetPrototype` y `Set-Prototype` son miembros públicos de `PrototypeCreator`, las dos funciones se propagan a través de `WidgetManager` y son accesibles directamente a los clientes.

Sin embargo, `WidgetManager` solo solicita la función miembro `Create`; eso es todo lo que `WidgetManager` necesita y utiliza para garantizar su propia funcionalidad. Los usuarios, sin embargo, pueden explotar la interfaz enriquecida.

Un usuario que utiliza una clase de política `Creator` basada en prototipos puede escribir el siguiente código:

```cpp
typedef WidgetManager<PrototypeCreator> MyWidgetManager;
...
Widget* pPrototype = ...;
MyWidgetManager mgr;
mgr.SetPrototype(pPrototype);
... use mgr ...
```

Si el usuario luego decide usar una política de creación que no admite prototipos, el compilador señala los puntos donde se utilizó la interfaz específica del prototipo. Esto es exactamente lo que se debe esperar de un diseño de sonido.

El contexto resultante es muy favorable. Los clientes que necesitan políticas enriquecidas pueden beneficiarse de esa rica funcionalidad, sin afectar la funcionalidad básica de la clase de host. No olvide que los usuarios, y no la biblioteca, deciden qué clase de política usar. A diferencia de las interfaces múltiples regulares, las políticas le dan al usuario la capacidad de agregar funcionalidad a una clase de host, de una manera segura.

## Destructores de clases de política

Hay un detalle importante adicional sobre la creación de clases de políticas. Muy a menudo, la clase de host utiliza la herencia pública para derivar de sus políticas. Por esta razón, el usuario puede convertir automáticamente una clase de host en una política y luego `delete` a ese puntero. A menos que la clase de política defina un destructor virtual, aplicando `delete` a un puntero a la clase de política tiene un comportamiento indefinido, como se muestra a continuación.

```cpp
typedef WidgetManager<PrototypeCreator> MyWidgetManager;
...
MyWidgetManager wm;
PrototypeCreator<Widget>* pCreator = &wm; // dubious, but legal
delete pCreator; // compiles fine, but has undefined behavior
```

Sin embargo, definir un destructor virtual para una política va en contra de su naturaleza estática y perjudica el rendimiento. Muchas políticas no tienen miembros de datos, sino que son puramente conductuales por naturaleza. La primera función virtual agregada incurre en una sobrecarga de tamaño para los objetos de esa clase, por lo que se debe evitar el destructor virtual.

Una solución es hacer que la clase de host use una herencia privada o protegida cuando se derive de la clase de política. Sin embargo, esto también deshabilitaría las políticas enriquecidas ([Políticas enriquecidas](#pol%c3%adticas-enriquecidas)).

La solución ligera y efectiva que deberían usar las políticas es definir un destructor protegido no virtual:

```cpp
template <class T>
struct OpNewCreator {
	static T* Create() {
		return new T;
	}
protected:
	~OpNewCreator() {}
};
```

Debido a que el destructor está protegido, solo las clases derivadas pueden destruir objetos de política, por lo que es imposible que los externos apliquen `delete` a un puntero a una clase de política. Sin embargo, el destructor no es virtual, por lo que no hay sobrecarga de tamaño o velocidad.

## Funcionalidad opcional a través de instanciación incompleta

Se pone aún mejor. `C++` contribuye al poder de las políticas al proporcionar una característica interesante. Si nunca se usa una función miembro de una plantilla de clase, ni siquiera se instancia; el compilador no la mira en absoluto, excepto quizás para la verificación de sintaxis.

De acuerdo con el estándar `C++`, el grado de verificación de sintaxis para las funciones de plantilla no utilizadas depende de la implementación. El compilador no realiza ninguna comprobación semántica; por ejemplo, los símbolos no se buscan.

Esto le da a la clase de host la oportunidad de especificar y usar características opcionales de una clase de política. Por ejemplo, definamos una función miembro `SwitchPrototype` para `WidgetManager`.

```cpp
// Library code
template <template <class> class CreationPolicy>
class WidgetManager : public CreationPolicy<Widget> {
	...
	void SwitchPrototype(Widget* pNewPrototype) {
		CreationPolicy<Widget>& myPolicy = *this;
		delete myPolicy.GetPrototype();
		myPolicy.SetPrototype(pNewPrototype);
	}
};
```

El contexto resultante es muy interesante:

- Si el usuario crea una instancia de `WidgetManager` con una clase de política `Creator` que admite prototipos, puede usar `SwitchPrototype`.
- Si el usuario crea una instancia de `WidgetManager` con una clase de política `Creator` que no admite prototipos e intenta usar `SwitchPrototype`, se produce un error en tiempo de compilación.
- Si el usuario crea una instancia de `WidgetManager` con una clase de política `Creator` que no admite prototipos y no intenta usar `SwitchPrototype`, el programa es válido.

Todo esto significa que `WidgetManager` puede beneficiarse de las interfaces enriquecidas opcionales, pero aún así funciona correctamente con interfaces más pobres, siempre y cuando no intente utilizar ciertas funciones miembro de `WidgetManager`.

El autor de `WidgetManager` puede definir la política `Creator` de la siguiente manera:

`Creator` prescribe una plantilla de clase de un tipo `T` que expone una función miembro `Create`. `Create` debería devolver un puntero a un nuevo objeto de tipo `T`. Opcionalmente, la implementación puede definir dos funciones miembro adicionales: `T * GetPrototype()` y `SetPrototype(T *)`, que tienen la semántica de obtener y establecer un prototipo de objeto utilizado para la creación. En este caso, `WidgetManager` expone la función miembro `SwitchPrototype(T * pNewPrototype)`, que elimina el prototipo actual y lo establece en el argumento entrante.

Junto con las clases de políticas, la creación de instancias incompletas le brinda una libertad notable como diseñador de bibliotecas. Puede implementar clases de host que pueden usar características adicionales y degradarse gentilmente, permitiendo políticas espartanas y mínimas.

## Combinando clases de política

La mayor utilidad de las políticas es evidente cuando las combina. Típicamente, una clase altamente configurable usa varias políticas para varios aspectos de su funcionamiento. Luego, el usuario de la biblioteca selecciona el comportamiento de alto nivel deseado combinando varias clases de políticas.

Por ejemplo, considere diseñar una clase genérica de puntero inteligente. (El Capítulo 7 construye una implementación completa). Supongamos que identifica dos opciones de diseño que debe establecer con las políticas: enhebrar el modelo y verificar antes de desreferenciar. Luego implementa una plantilla de clase `SmartPtr` que usa dos políticas, como se muestra:

```cpp
template
<
	class T,
	template <class> class CheckingPolicy,
	template <class> class ThreadingModel
>
class SmartPtr;
```

`SmartPtr` tiene tres parámetros de plantilla: el tipo al que apunta y dos políticas. Dentro de `SmartPtr`, usted organiza las dos políticas en una implementación sólida. `SmartPtr` viene con un shell coherente que integra varias políticas, en lugar de una implementación rígida y enlatada. Al diseñar `SmartPtr` de esta manera, le permite al usuario configurar `SmartPtr` con un simple typedef:

```cpp
typedef SmartPtr<Widget, NoChecking, SingleThreaded> WidgetPtr;
```

Dentro de la misma aplicación, puede definir y usar varias clases de punteros inteligentes:

```cpp
typedef SmartPtr<Widget, EnforceNotNull, SingleThreaded> SafeWidgetPtr;
```

Las dos políticas se pueden definir de la siguiente manera:

Checking: la plantilla de clase `CheckingPolicy<T>` debe exponer una función miembro `Check`, invocable con un lvalue de tipo `T *`. `SmartPtr` llama a `Check`, pasándole el objeto de puntero antes de desreferenciarlo.

ThreadingModel: la plantilla de clase `ThreadingModel<T>` debe exponer un tipo interno llamado `Lock`, cuyo constructor acepta un `T &`. Durante la vida útil de un objeto `Lock`, las operaciones en el objeto `T` se serializan.

Por ejemplo, aquí está la implementación de las clases de política `NoChecking` y `EnforceNotNull`:

```cpp
template <class T> struct NoChecking {
	static void Check(T*) {}
};

template <class T> struct EnforceNotNull {
	class NullPointerException : public std::exception { ... };
	static void Check(T* ptr) {
		if (!ptr) throw NullPointerException();
	}
};
```

Al conectar varias clases de políticas de verificación, puede implementar varios comportamientos. Incluso puede inicializar el objeto de puntero con un valor predeterminado aceptando una referencia a un puntero, como se muestra:

```cpp
template <class T> struct EnsureNotNull {
	static void Check(T*& ptr) {
		if (!ptr) ptr = GetDefaultValue();
	}
};
```

`SmartPtr` utiliza la política de verificación de esta manera:

```cpp
template
<
	class T,
	template <class> class CheckingPolicy,
	template <class> class ThreadingModel
>
class SmartPtr
	: public CheckingPolicy<T>
	, public ThreadingModel<SmartPtr>
{
	...
	T* operator->() {
		typename ThreadingModel<SmartPtr>::Lock guard(*this);
		CheckingPolicy<T>::Check(pointee_);
		return pointee_;
	}
private:
	T* pointee_;
};
```

Observe el uso de las clases de política `CheckingPolicy` y `ThreadingModel` en la misma función. Dependiendo de los dos argumentos de plantilla, `SmartPtr::operator->` se comporta de manera diferente en dos dimensiones ortogonales. Tal es el poder de combinar las políticas.

Si logra descomponer una clase en políticas ortogonales, puede cubrir un amplio espectro de comportamientos con una pequeña cantidad de código.

## Personalizar la estructura con clases de política

Una de las limitaciones de las plantillas, mencionadas en la sección [El beneficio de la plantillas](#el-beneficio-de-la-plantillas), es que no puede usar plantillas para personalizar la estructura de una clase, solo su comportamiento. Los diseños basados en políticas, sin embargo, admiten la personalización estructural de manera natural.

Suponga que desea admitir representaciones sin puntero para `SmartPtr`. Por ejemplo, en ciertas plataformas, algunos punteros pueden estar representados por un controlador, un valor integral que pasa a una función del sistema para obtener el puntero real. Para resolver esto, puede "indirecta" el acceso del puntero a través de una política, por ejemplo, una política de Estructura. La política Estructura abstrae el almacenamiento del puntero. En consecuencia, `Structure` debería exponer tipos llamados `PointerType` (el tipo del objeto señalado) y `ReferenceType` (el tipo al que se refiere el puntero) y funciones como `GetPointer` y `SetPointer`.

El hecho de que el tipo de puntero no esté codificado en `T *` tiene ventajas importantes. Por ejemplo, puede usar `SmartPtr` con tipos de puntero no estándar (como punteros `near` y `far` en arquitecturas segmentadas), o puede implementar fácilmente soluciones inteligentes como funciones `before` y `after` (Stroustrup 2000a). Las posibilidades son extremadamente interesantes.

El almacenamiento predeterminado de un puntero inteligente es un puntero simple adornado con la interfaz de política de Estructura, como se muestra en el siguiente código.

```cpp
template <class T>
class DefaultSmartPtrStorage {
public:
	typedef T* PointerType;
	typedef T& ReferenceType;
protected:
	PointerType GetPointer() { return ptr_; }
	void SetPointer(PointerType ptr) { pointee_ = ptr; }
private:
	PointerType ptr_;
};
```

El almacenamiento real utilizado está completamente oculto detrás de la interfaz de Structure. Ahora `SmartPtr` puede usar una política de almacenamiento en lugar de agregar un `T *`.

```cpp
template
<
	class T,
	template <class> class CheckingPolicy,
	template <class> class ThreadingModel,
	template <class> class Storage = DefaultSmartPtrStorage
>
class SmartPtr;
```

Por supuesto, `SmartPtr` debe derivar de `Storage<T>` o agregar un objeto `Storage<T>` para incrustar la estructura necesaria.

## Políticas compatibles e incompatibles

Suponga que crea dos instancias de `SmartPtr`: `FastWidgetPtr`, un puntero sin verificación, y `SafeWidgetPtr`, un puntero con verificación antes de la desreferencia. Una pregunta interesante es: ¿Debería poder asignar objetos `FastWidgetPtr` a objetos `SafeWidgetPtr`? ¿Debería poder asignarlos al revés? Si desea permitir tales conversiones, ¿cómo puede implementar eso?

Partiendo del razonamiento de que `SafeWidgetPtr` es más restrictivo que `FastWidgetPtr`, es natural aceptar la conversión de `FastWidgetPtr` a `SafeWidgetPtr`. Esto se debe a que `C++` ya admite conversiones implícitas que aumentan las restricciones, es decir, de tipos no constantes a constantes.

Por otro lado, convertir libremente objetos `SafeWidgetPtr` en objetos `FastWidgetPtr` es peligroso. Esto se debe a que en una aplicación, la mayoría del código usaría `SafeWidgetPtr` y solo un núcleo pequeño y crítico para la velocidad usaría `FastWidgetPtr`. Permitir solo conversiones explícitas y controladas a `FastWidgetPtr` ayudaría a mantener el uso de `FastWidgetPtr` al mínimo.

La mejor y más escalable forma de implementar conversiones entre políticas es inicializar y copiar la política de objetos `SmartPtr` por política, como se muestra a continuación. (Simplifiquemos el código volviendo a una sola política: la política de verificación).

```cpp
template
<
	class T,
	template <class> class CheckingPolicy
>
class SmartPtr : public CheckingPolicy<T> {
	...
	template
	<
		class T1,
		template <class> class CP1,
	>
	SmartPtr(const SmartPtr<T1, CP1>& other)
		: pointee_(other.pointee_), CheckingPolicy<T>(other)
	{ ... }
};
```

`SmartPtr` implementa un constructor de copia con plantilla, que acepta cualquier otra instancia de `SmartPtr`. El código en negrita inicializa los componentes de `SmartPtr` con los componentes del otro `SmartPtr<T1, CP1>` recibido como argumentos.

Así es como funciona. (Siga el código del constructor). Suponga que tiene una clase `ExtendedWidget`, derivada de `Widget`. Si inicializa un `SmartPtr<Widget, NoChecking>` con un `SmartPtr<ExtendedWidget, NoChecking>`, el compilador intenta inicializar un `Widget *` con un `ExtendedWiget *` (que funciona) y un `NoChecking` con un `SmartPtrExtended<Widget, NoChecking>`. Esto puede parecer sospechoso, pero no olvide que `SmartPtr` se deriva de su política, por lo que, en esencia, el compilador descubrirá fácilmente que inicializa un `NoChecking` con un `NoChecking`. Toda la inicialización funciona.

Ahora para la parte interesante. Supongamos que inicializa un `SmartPtr<Widget, EnforceNotNull>` con un `SmartPtr<ExtendedWidget, NoChecking>`. La conversión de `ExtendedWidget *` a `Widget *` funciona igual que antes. Luego, el compilador intenta hacer coincidir `SmartPtr<ExtendedWidget, NoChecking>` con los constructores de `EnforceNotNull`.

Si `EnforceNotNull` implementa un constructor que acepta un objeto `NoChecking`, entonces el compilador coincide con ese constructor. Si `NoChecking` implementa un operador de conversión a `EnforceNotNull`, se invoca esa conversión. En cualquier otro caso, el código no se compila.

Como puede ver, tiene flexibilidad bilateral para implementar conversiones entre políticas. Puede implementar un constructor de conversión en el lado izquierdo, o puede implementar un operador de conversión en el lado derecho.

El operador de asignación parece un problema igualmente complicado, pero afortunadamente, Sutter (2000) describe una técnica muy ingeniosa que le permite implementar el operador de asignación en términos del constructor de copia. (Es tan ingenioso que tienes que leer al respecto. Puedes ver la técnica en funcionamiento en la implementación de `SmartPtr` de Loki).

Aunque las conversiones de `NoChecking` a `EnforceNotNull` e incluso viceversa son bastante sensatas, algunas conversiones no tienen ningún sentido. Imagine convertir un puntero contado por referencia en un puntero que admita otra estrategia de propiedad, como una copia destructiva (à la `std::auto_ptr`). Tal conversión es semánticamente incorrecta. La definición del recuento de referencias es que todos los punteros al mismo objeto son conocidos y rastreados por un contador único. Tan pronto como intente limitar un puntero a otra política de propiedad, romperá la invariante que hace que el recuento de referencias funcione.

En conclusión, las conversiones que cambian la política de propiedad no deben permitirse implícitamente y deben tratarse con el máximo cuidado. En el mejor de los casos, puede cambiar la política de propiedad de un puntero contado por referencia llamando explícitamente a una función. Esa función tiene éxito si y solo si el recuento de referencia del puntero de origen es 1.

## Descomponer una clase en políticas

La parte más difícil de crear un diseño de clase basado en políticas es descomponer correctamente la funcionalidad de una clase en políticas. La regla general es identificar y nombrar las decisiones de diseño que participan en el comportamiento de una clase. Cualquier cosa que se pueda hacer de más de una manera debe identificarse y migrarse de la clase a una política. No olvides: las restricciones de diseño ocultas en el diseño de una clase son tan malas como las constantes mágicas enterradas en el código.

Por ejemplo, considere una clase `WidgetManager`. Si `WidgetManager` crea nuevos objetos `Widget` internamente, la creación debe diferirse a una política. Si `WidgetManager` almacena una colección de `Widgets`, tiene sentido hacer que esa colección sea una política de almacenamiento, a menos que haya una fuerte preferencia por un mecanismo de almacenamiento específico.

En un extremo, una clase de host está totalmente agotada de cualquier política intrínseca. Delega todas las decisiones de diseño y restricciones a las políticas. Tal clase de host es un shell sobre una colección de políticas y solo trata de ensamblar las políticas en un comportamiento coherente.

La desventaja de una clase de host demasiado genérica es la abundancia de parámetros de plantilla. En la práctica, es incómodo trabajar con más de cuatro a seis parámetros de plantilla. Aún así, justifican su presencia si la clase de host ofrece una funcionalidad compleja y útil.

Las definiciones de tipo (sentencias `typedef`) son una herramienta esencial en el uso de clases que se basan en políticas. Usar `typedef` no es simplemente una cuestión de conveniencia; asegura el uso ordenado y fácil mantenimiento. Por ejemplo, considere la siguiente definición de tipo:

```cpp
typedef SmartPtr<Widget, RefCounted, NoChecked> WidgetPtr;
```

Sería muy tedioso usar la larga especialización de `SmartPtr` en lugar de `WidgetPtr` en el código. Pero lo tedioso de escribir código no es nada comparado con los principales problemas para comprender y mantener ese código. A medida que el diseño evoluciona, la definición de `WidgetPtr` puede cambiar, por ejemplo, para usar una política de verificación que no sea `NoChecked` en las compilaciones de depuración. Es esencial que todo el código use `WidgetPtr` en lugar de una instanciación codificada de `SmartPtr`. Es como la diferencia entre llamar a una función y escribir el código en línea equivalente: el código en línea técnicamente hace lo mismo, pero no puede generar una abstracción detrás de él.

Cuando descompone una clase en políticas, es muy importante encontrar una descomposición ortogonal. Una descomposición ortogonal produce políticas que son completamente independientes entre sí. Puede detectar fácilmente una descomposición no ortogonal cuando varias políticas deben conocerse entre sí.

Por ejemplo, piense en una política de matriz en un puntero inteligente. La política de matriz es muy simple: dicta si el puntero inteligente apunta o no a una matriz. La política se puede definir para tener una función miembro `T &ElementAt(T * ptr, unsigned int index)`, más una versión similar para `const T`. La política sin matriz simplemente no define una función miembro `ElementAt`, por lo que intentar usarla produciría un error en tiempo de compilación. La función `ElementAt` es un comportamiento enriquecido opcional como se define en la sección [Políticas enriquecidas](#pol%c3%adticas-enriquecidas).

Siguen las implementaciones de dos clases de políticas que implementan la política de matriz.

```cpp
template <class T>
struct IsArray {
	T& ElementAt(T* ptr, unsigned int index) {
		return ptr[index];
	}
	const T& ElementAt(T* ptr, unsigned int index) const {
		return ptr[index];
	}
};

template <class T> struct IsNotArray {};
```

El problema es que el propósito de la política de matriz, que especifica si el puntero inteligente apunta o no a una matriz, interactúa desfavorablemente con otra política: la destrucción. Debe destruir los punteros a los objetos con el operador `delete` y destruir los punteros a las matrices de objetos con el operador `delete []`.

Dos políticas que no interactúan entre sí son ortogonales. Según esta definición, las políticas Array y Destroy no son ortogonales.

Si aún necesita limitar las cualidades de ser un conjunto y de destrucción a políticas separadas, debe establecer una forma para que las dos políticas se comuniquen. Debe hacer que la política de matriz exponga una constante booleana además de una función, y pasar esa booleana a la política de destrucción. Esto complica y limita de alguna manera el diseño de las políticas Array y Destroy.

Las políticas no ortogonales son una imperfección que debe tratar de evitar. Reducen la seguridad del tipo de tiempo de compilación y complican el diseño tanto de la clase de host como de las clases de política.

Si debe utilizar políticas no ortogonales, puede minimizar las dependencias pasando una clase de política como argumento a la función de plantilla de otra clase de política. De esta manera, puede beneficiarse de la flexibilidad específica de las interfaces basadas en plantillas. La desventaja sigue siendo que una política debe exponer algunos de sus detalles de implementación a otras políticas. Esto disminuye la encapsulación.

## Resumen

El diseño es elección. La mayoría de las veces, la lucha no es que no haya forma de resolver un problema de diseño, sino que hay muchas maneras en que aparentemente se resuelve el problema. Debe saber qué conjunto de soluciones resuelve el problema de manera satisfactoria. La necesidad de elegir se propaga desde los niveles arquitectónicos más grandes hasta la unidad de código más pequeña. Además, las opciones se pueden combinar, lo que confiere al diseño una multiplicidad malvada.

Para combatir la multiplicidad de diseño con una cantidad de código razonablemente pequeña, un escritor de una biblioteca orientada al diseño necesita desarrollar y usar técnicas especiales. Estas técnicas están concebidas a propósito para admitir la generación de código flexible mediante la combinación de un pequeño número de dispositivos primitivos. La biblioteca misma proporciona varios dispositivos de este tipo. Además, la biblioteca expone las especificaciones a partir de las cuales se construyen estos dispositivos, para que el cliente pueda construir la suya propia. Esto esencialmente hace que un diseño basado en políticas sea abierto. Estos dispositivos se denominan políticas, y sus implementaciones se denominan clases de políticas.

La mecánica de las políticas consiste en una combinación de plantillas con herencia múltiple. Una clase que utiliza políticas (una clase de host) es una plantilla con muchos parámetros de plantilla (a menudo, parámetros de plantilla de plantilla), cada parámetro es una política. La clase de host "indirecta" partes de su funcionalidad a través de sus políticas y actúa como un receptáculo que combina varias políticas en un agregado coherente.

Las clases diseñadas en torno a políticas admiten un comportamiento enriquecido y una degradación elegante de la funcionalidad. Una política puede proporcionar una funcionalidad complementaria que se propaga a través de la clase de host debido a la herencia pública. Además, la clase de host puede implementar una funcionalidad enriquecida que utiliza la funcionalidad opcional de una política. Si la funcionalidad opcional no está presente, la clase de host aún se compila correctamente, siempre que no se utilice la funcionalidad enriquecida.

El poder de las políticas proviene de su capacidad de mezclar y combinar. Una clase basada en políticas puede acomodar muchos comportamientos combinando los comportamientos más simples que implementan sus políticas. Esto hace que las políticas sean una buena arma para luchar contra la malvada multiplicidad del diseño.

Usando clases de políticas, puede personalizar no solo el comportamiento sino también la estructura. Esta característica importante lleva el diseño basado en políticas más allá de la simple genérica de tipo que es específica de las clases de contenedor.

Las clases basadas en políticas admiten flexibilidad cuando se trata de conversiones. Si utiliza la copia de política por política, cada política puede controlar a qué otras políticas aceptan o se convierten, proporcionando los constructores de conversión, operadores de conversión o ambos adecuados.

Al dividir una clase en políticas, debe seguir dos pautas importantes. Una es localizar, nombrar y aislar las decisiones de diseño en su clase, cosas que están sujetas a una compensación o que podrían implementarse de manera sensata de otras maneras. La otra guía es buscar políticas ortogonales, es decir, políticas que no necesiten interactuar entre sí y que se puedan cambiar de forma independiente.

Al dividir una clase en políticas, debe seguir dos pautas importantes. Una es localizar, nombrar y aislar las decisiones de diseño en su clase, cosas que están sujetas a una compensación o que podrían implementarse de manera sensata de otras maneras. La otra guía es buscar políticas ortogonales, es decir, políticas que no necesiten interactuar entre sí y que se puedan cambiar de forma independiente.
