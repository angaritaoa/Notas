# Typelists

- [Typelists](#typelists)
	- [La necesidad de listas de tipos](#la-necesidad-de-listas-de-tipos)
	- [Definir listas de tipos](#definir-listas-de-tipos)
	- [Creación de listas de tipos de linealización](#creaci%c3%b3n-de-listas-de-tipos-de-linealizaci%c3%b3n)
	- [Longitud calculadora](#longitud-calculadora)
	- [Intermezzo](#intermezzo)
	- [Acceso indexado](#acceso-indexado)
	- [Buscar listas de tipos](#buscar-listas-de-tipos)
	- [Agregar a listas de tipos](#agregar-a-listas-de-tipos)
	- [Borrar un tipo de una lista de tipos](#borrar-un-tipo-de-una-lista-de-tipos)
	- [Borrar duplicados](#borrar-duplicados)
	- [Sustitución de un elemento en una lista de tipos](#sustituci%c3%b3n-de-un-elemento-en-una-lista-de-tipos)
	- [Listas de tipos ordenadas parcialmente](#listas-de-tipos-ordenadas-parcialmente)
	- [Generación de clase con listas de tipos](#generaci%c3%b3n-de-clase-con-listas-de-tipos)
		- [Generando jerarquías dispersas](#generando-jerarqu%c3%adas-dispersas)

---

Las listas de tipos son una herramienta de `C++` para manipular colecciones de tipos. Ofrecen para los tipos todas las operaciones fundamentales que soportan las listas de valores.

Algunos patrones de diseño especifican y manipulan colecciones de tipos, ya sea relacionados por herencia o no. Ejemplos notables son Abstract Factory y Visitor (Gamma et al. 1995). Si utiliza técnicas de codificación tradicionales, puede manipular colecciones de tipos por simple repetición. Esta repetición conduce a una forma sutil de hinchazón de código. La mayoría de la gente no cree que pueda ser mejor que eso. Sin embargo, las listas de tipos le permiten automatizar tareas que generalmente limita a la capacidad macro de su editor. Las listas de tipos traen poder de otro planeta a `C++`, lo que le permite admitir expresiones idiomáticas nuevas e interesantes.

Este capítulo está dedicado a presentar una instalación completa de listas de tipos para `C++`, junto con un par de ejemplos de su uso. Después de leer este capítulo, podrás:

- Comprender el concepto de lista de tipos
- Comprender cómo se pueden crear y procesar las listas de tipos
- Poder manipular las listas de tipos de manera efectiva
- Conozca los principales usos de las listas de tipos y los modismos de programación que permiten y admiten

Los capítulos 9, 10 y 11 usan listas de tipos como tecnología habilitadora.

## La necesidad de listas de tipos

A veces debe repetir el mismo código para varios tipos, y las plantillas no pueden ser de ayuda. Considere, por ejemplo, implementar una Fábrica abstracta (Gamma et al. 1995). Aquí define una función virtual para cada tipo en una colección de tipos conocidos en tiempo de diseño:

```cpp
class WidgetFactory {
public:
	virtual Window* CreateWindow() = 0;
	virtual Button* CreateButton() = 0;
	virtual ScrollBar* CreateScrollBar() = 0;
};
```

Si desea generalizar el concepto de Abstract Factory y ponerlo en una biblioteca, debe hacer posible que el usuario cree fábricas de colecciones arbitrarias de tipos, no solo `Window`, `Button` y `ScrollBar`. Las plantillas no admiten esta característica de fábrica.

Aunque al principio Abstract Factory no parezca brindar muchas oportunidades para la abstracción y la generalización, hay algunas cosas que hacen que la investigación valga la pena:

1. Si no puede intentar generalizar el concepto fundamental, no tendrá la oportunidad de generalizar las instancias concretas de ese concepto. Este es un principio crucial. Si la esencia escapa a la generalización, continúas luchando con los artefactos concretos de esa esencia. En el caso de Abstract Factory, aunque la clase base abstracta es bastante simple, puede obtener una cantidad desagradable de duplicación de código al implementar varias fábricas concretas.

1. No puede manipular fácilmente las funciones miembro de `WidgetFactory` (consulte el código anterior). Una colección de firmas de funciones virtuales es esencialmente imposible de manejar de manera genérica. Por ejemplo, considere esto:

	```cpp
	template <class T>
	T* MakeRedWidget(WidgetFactory& factory) {
		T* pW = factory.CreateT(); // huh???
		pW->SetColor(RED);
		return pW;
	}
	```
	Debe llamar a `CreateWindow`, `CreateButton` o `CreateScrollBar`, dependiendo de que `T` sea una ventana, un botón o una barra de desplazamiento, respectivamente. `C++` no le permite hacer este tipo de sustitución de texto.

1. Por último, pero no menos importante, las buenas bibliotecas tienen el agradable efecto secundario de dejar de lado los debates interminables sobre las convenciones de nomenclatura (`createWindow`, `create_window` o `CreateWindow`?) Y pequeños ajustes como ese. Presentan una forma preferida y estandarizada de hacer las cosas. Resumiendo, bueno, Abstract Factory tendría este agradable efecto secundario.

Vamos a armar una lista de deseos. Para abordar el elemento 1, sería bueno si pudiéramos crear un `WidgetFactory` pasando una lista de parámetros a una plantilla `AbstractFactory`:

```cpp
typedef AbstractFactory<Window, Button, ScrollBar> WidgetFactory;
```

Para abordar el elemento 2, necesitamos una invocación similar a una plantilla para varias funciones `CreateXxx`, como `Create<Window>()`, `Create<Button>()`, y así sucesivamente. Entonces podemos invocarlo desde un código genérico:

```cpp
template <class T>
T* MakeRedWidget(WidgetFactory& factory) {
	T* pW = factory.Create<T>(); // aha!
	pW->SetColor(RED);
	return pW;
}
```

Sin embargo, no podemos satisfacer estas necesidades. Primero, el `typedef` para `WidgetFactory` anterior no es posible porque las plantillas no pueden tener un número variable de parámetros. En segundo lugar, la sintaxis de la plantilla `Create<Xxx>()` no es legal porque las funciones virtuales no pueden ser plantillas.

En este punto, debería ver qué buenas oportunidades de abstracción y reutilización tenemos, y cuán mal estamos limitados a explotar estas oportunidades debido a las limitaciones del idioma.

Las listas de tipos permiten crear Fábricas abstractas genéricas y mucho más.

## Definir listas de tipos

Por una variedad de razones, `C++` es un lenguaje que hace que sus usuarios a veces digan: "Estas son las cinco líneas de código más inteligentes que jamás haya escrito". Tal vez sea su riqueza semántica o la forma cada vez más emocionante (¿y sorprendente?) Que interactúan sus características. En línea con esta tradición, las listas de tipos son fundamentalmente muy simples:

```cpp
template <class T, class U>
struct Typelist {
	typedef T Head;
	typedef U Tail;
};

namespace TL {
	...typelist algorithms ...
}
```

Todo lo relacionado con las listas de tipos, excepto la definición de la misma, vive en el espacio de nombres `TL`. A su vez, `TL` está dentro del espacio de nombres de Loki, al igual que todo el código de Loki. Para simplificar los ejemplos, este capítulo omite mencionar el espacio de nombres `TL`. Tendrá que recordarlo cuando use el encabezado `Typelist.h`. (Si lo olvida, el compilador le recordará).

La lista de tipos contiene dos tipos. Son accesibles a través de los nombres internos de `Head` and `Tail`. ¡Eso es! No necesitamos listas de tipos que contengan tres o más elementos, porque ya los tenemos. Por ejemplo, aquí hay una lista de tipos de tres elementos que contienen las tres variantes de caracteres de `C++`:

```cpp
typedef Typelist<char, Typelist<signed char, unsigned char> > CharList;
```

> Observe el molesto pero requerido espacio entre los dos tokens al final.

Las listas de tipos carecen de cualquier valor: sus cuerpos están vacíos, no tienen ningún estado y no definen ninguna funcionalidad. En tiempo de ejecución, las listas de tipos no tienen ningún valor en absoluto. Su única *razón de ser* es llevar información de tipo. Se deduce que cualquier procesamiento de lista de tipos debe ocurrir necesariamente en tiempo de compilación, no en tiempo de ejecución. Las listas de tipos no están destinadas a ser instanciadas, aunque no hay nada de malo en hacer esto. Por lo tanto, cada vez que este libro habla de "una lista de tipos", realmente se refiere a un tipo de lista de tipos, no a un valor de lista de tipos. Los valores de la lista de tipos no son interesantes; solo sus tipos son de utilidad. (La Sección 3.13.2 muestra cómo usar listas de tipos para crear colecciones de valores).

La propiedad de las plantillas utilizadas aquí es que un parámetro de plantilla puede ser de cualquier tipo, incluida otra instanciación de la misma plantilla. Esta es una propiedad antigua y bien conocida de las plantillas, a menudo utilizada para implementar matrices ad hoc como `vector< vector<double> >`. Debido a que `Typelist` acepta dos parámetros, siempre podemos extender una `Typelist` dada reemplazando uno de los parámetros con otra `Typelist`, *ad infinitum*.

Sin embargo, hay un pequeño problema. Podemos expresar listas de tipos de dos tipos o más, pero no podemos expresar listas de tipos que contengan cero o un tipo. Lo que se necesita es un *tipo de lista nula*, y la clase `NullType` descrita en el Capítulo 2 es exactamente adecuada para tales usos.

Establecemos la convención de que cada lista de tipos debe terminar con un `NullType`. `NullType` sirve como un útil marcador de terminación, al igual que el `\0` que ayuda a las funciones tradicionales de la cadena `C`. Ahora podemos definir una lista de tipos de un solo elemento:

```cpp
// See Chapter 2 for the definition of NullType
typedef Typelist<int, NullType> OneTypeOnly;
```

La lista de tipos que contiene las tres variantes de caracteres se convierte en:

```cpp
typedef Typelist<char, Typelist<signed char, Typelist<unsigned char, NullType> > > AllCharTypes;
```

Por lo tanto, hemos obtenido una plantilla de Lista de tipos abierta que puede, al combinar una celda básica, contener cualquier número de tipos.

Veamos ahora cómo podemos manipular las listas de tipos. (Nuevamente, esto significa tipos `Typelist`, no objetos `Typelist`). Prepárese para un viaje interesante. De aquí en adelante nos adentramos en el subsuelo de `C++`, un mundo con reglas nuevas y extrañas: el mundo de la programación en tiempo de compilación.

## Creación de listas de tipos de linealización

De inmediato, las listas de tipos son demasiado LISP-ish para ser fáciles de usar. Las construcciones de estilo LISP son excelentes para los programadores de LISP, pero no encajan bien con `C++` (por no hablar de los espacios entre >s que debe cuidar). Por ejemplo, aquí hay una lista de tipos de tipos integrales:

```cpp
typedef Typelist<signed char, Typelist<short int, Typelist<int, Typelist<long int, NullType> > > > SignedIntegrals;
```

Las listas de tipos pueden ser un concepto genial, pero definitivamente necesitan un mejor empaque.

Para linealizar la creación de la lista de tipos, la biblioteca de la lista de tipos (vea el archivo `Typelist.h` de Loki) define una gran cantidad de macros que transforman la recursión en una enumeración simple, a expensas de la repetición tediosa. Sin embargo, esto no es un problema. La repetición se realiza solo una vez, en el código de la biblioteca, y escala las listas de tipos a un número grande definido por la biblioteca (50). Las macros se ven así:

```cpp
#define TYPELIST_1(T1) Typelist<T1, NullType>
#define TYPELIST_2(T1, T2) Typelist<T1, TYPELIST_1(T2) >
#define TYPELIST_3(T1, T2, T3) Typelist<T1, TYPELIST_2(T2, T3) >
#define TYPELIST_4(T1, T2, T3, T4) Typelist<T1, TYPELIST_3(T2, T3, T4) >
...
#define TYPELIST_50(...) ...
```

Cada macro usa la anterior, lo que facilita que el usuario de la biblioteca extienda el límite superior, en caso de que surja esta necesidad.

Ahora la definición de tipo anterior de `SignedIntegrals` se puede expresar de una manera mucho más agradable:

```cpp
typedef TYPELIST_4(signed char, short int, int, long int) SignedIntegrals;
```

La creación de listas de tipos linealizadas es solo el comienzo. La manipulación de la lista de tipos sigue siendo muy torpe. Por ejemplo, acceder al último elemento en `SignedIntegrals` requiere usar `SignedIntegrals::Tail::Tail::Head`. Todavía no está claro cómo podemos manipular las listas de tipos genéricamente. Es hora, entonces, de definir algunas operaciones fundamentales para las listas de tipos al pensar en las operaciones primitivas disponibles para las listas de valores.

## Longitud calculadora

Aquí hay una operación simple. Dada una lista de tipos `TList`, obtenga una constante de tiempo de compilación que evalúe su longitud. La constante debe ser en tiempo de compilación porque las listas de tipos son construcciones estáticas, por lo que esperaríamos que todos los cálculos relacionados con las listas de tipos se realicen en tiempo de compilación.

La idea subyacente en la mayoría de las manipulaciones de listas de tipos es explotar las plantillas recursivas, que son plantillas que usan instancias de sí mismas como parte de su definición. Al hacer esto, pasan una lista de argumentos de plantilla diferente. La recursión obtenida de esta manera se detiene con una especialización explícita para un caso límite.

El código que calcula la longitud de una lista de tipos es, nuevamente, bastante conciso:

```cpp
template <class TList> struct Length;
template <> struct Length<NullType> {
	enum { value = 0 };
};

template <class T, class U>
struct Length< Typelist<T, U> > {
	enum { value = 1 + Length<U>::value };
};
```

Esta es la forma en C++ de decir: "La longitud de una lista de tipos nula es 0. La longitud de cualquier otra lista de tipos es 1 más la longitud de la cola de esa lista de tipos".

La implementación de `Length` utiliza la *especialización de plantilla parcial* (consulte el Capítulo 2) para distinguir entre un tipo nulo y una lista de tipos. La primera especialización de `Length` es totalmente especializada y solo coincide con `NullType`. La segunda especialización parcial de `Length` coincide con cualquier `Typelist<T, U>`, incluidas las listas de tipos compuestos, es decir, aquellas en las que `U` es a su vez una `Typelist<V, W>`.

La segunda especialización realiza el cálculo por recursión. Define `value` como 1 (que cuenta la cabeza `T`) más la longitud de la cola de la lista de tipos. Cuando la cola se convierte en `NullType`, la primera definición coincide, la recursión se detiene y también el cálculo de la longitud, que vuelve muy bien con el resultado. Supongamos, por ejemplo, que desea definir una matriz al estilo de `C` que recopile punteros a objetos `std::type_info` para todas las integrales con signo. Usando `Length`, puedes escribir:

```cpp
std::type_info* intsRtti[Length<SignedIntegrals>::value];
```

Se asignan cuatro elementos para `intsRtti` a través de un cálculo en tiempo de compilación.

> También puede inicializar la matriz sin repetición de código. Hacer esto se deja como un ejercicio para el lector.


## Intermezzo

Puede encontrar ejemplos tempranos de metaprogramas de plantilla en Veldhuizen (1995). Czarnecki y Eisenecker (2000) discuten este problema en profundidad y proporcionan una colección completa de simulaciones en tiempo de compilación para declaraciones `C++`.

La concepción e implementación de `Length` se asemeja a un ejemplo clásico de recursividad dado en las clases de informática: el algoritmo que calcula la longitud de una estructura de lista vinculada individualmente. (Sin embargo, hay dos diferencias principales: el algoritmo para `Length` se realiza en tiempo de compilación y funciona en tipos, no en valores).

Esto naturalmente lleva a la siguiente pregunta: ¿No podríamos desarrollar una versión de `Length` que sea iterativa, en lugar de recursiva? Después de todo, la iteración es más natural para `C++` que la recursividad. Obtener una respuesta a esta pregunta nos guiará en la implementación de las otras instalaciones de `Typelist`.

La respuesta es no, y por razones interesantes.

Nuestras herramientas para la programación en tiempo de compilación en `C++` son plantillas, cálculos enteros en tiempo de compilación y definiciones de tipo (`typedefs`). Veamos de qué manera nos sirve cada una de estas herramientas.

Las plantillas, más específicamente, la especialización de plantillas, proporcionan el equivalente de las declaraciones if en tiempo de compilación. Como se vio anteriormente en la implementación de Longitud, la especialización de plantilla permite la diferenciación entre listas de tipos y otros tipos.

Los cálculos de enteros le permiten realizar cálculos de valor verdadero, para saltar de tipos a valores. Sin embargo, hay una peculiaridad: todos los valores en tiempo de compilación son *inmutables*. Después de haber definido una constante integral, digamos un valor enumerado, no puede cambiarlo (es decir, asignarle otro valor).

Las definiciones de tipo (`typedefs`) pueden verse como la introducción de constantes de tipo con nombre. Una vez más, después de la definición, se congelan; más adelante no puede redefinir un símbolo de `typedef` para contener otro tipo.

Estas dos peculiaridades del cálculo en tiempo de compilación lo hacen fundamentalmente incompatible con la iteración. La iteración consiste en mantener un iterador y cambiarlo hasta que se cumpla alguna condición. Debido a que no tenemos entidades mutables en el mundo en tiempo de compilación, no podemos hacer ninguna iteración en absoluto. Por lo tanto, aunque `C++` es principalmente un lenguaje imperativo, cualquier cómputo en tiempo de compilación debe basarse en técnicas que definitivamente recuerden a los lenguajes funcionales puros, lenguajes que no pueden mutar valores. Prepárate para recurrir fuertemente.

## Acceso indexado

Tener acceso por índice a los elementos de una lista de tipos sin duda sería una característica deseable. Linealizaría el acceso a la lista de tipos, facilitando la manipulación cómoda de las listas de tipos. Por supuesto, como con todas las entidades que manipulamos en nuestro mundo estático, el índice debe ser un valor de tiempo de compilación.

La declaración de una plantilla para una operación indexada se vería así:

```cpp
template <class TList, unsigned int index> struct TypeAt;
```

Definamos el algoritmo. Tenga en cuenta que no podemos usar valores mutables y modificables.

<kbd>TypeAt</kbd>

| Entradas                           | Salidas               |
| ---------------------------------- | --------------------- |
| Lista de tipos `TList`, indice `i` | Tipo interno `Result` |

- Si `TList` no es `null` e `i` es cero, entonces `Result` es la cabeza de `TList`.
- De lo contrario
- Si `TList` no es `null` y el índice `i` no es cero, el resultado se obtiene aplicando `TypeAt` a la cola de `TList` e `i-1`.
- De lo contrario, hay un acceso fuera de límite que se traduce en un error en tiempo de compilación.

Aquí está la encarnación del algoritmo `TypeAt`:

```cpp
template <class Head, class Tail>
struct TypeAt<Typelist<Head, Tail>, 0> {
	typedef Head Result;
};

template <class Head, class Tail, unsigned int i>
struct TypeAt<Typelist<Head, Tail>, i> {
	typedef typename TypeAt<Tail, i - 1>::Result Result;
};
```

Si intenta un acceso fuera de límite, el compilador se quejará de que no hay una especialización definida para `TypeAt<NullType, x>`, donde `x` es la cantidad por la que omite el tamaño de la lista. Este mensaje podría ser un poco más informativo, pero tampoco está mal.

Loki (archivo `Typelist.h`) también define una variante de `TypeAt`, llamada `TypeAtNonStrict`. `TypeAtNonStrict` implementa la misma funcionalidad que `TypeAt`, con la diferencia de que un acceso fuera de enlace es más indulgente, produciendo un tipo predeterminado elegido por el usuario como resultado en lugar de un error en tiempo de compilación. La implementación de devolución de llamada generalizada descrita en el Capítulo 5 utiliza `TypeAt-NonStrict`.

El acceso indexado en las listas de tipos lleva un tiempo lineal de acuerdo con el tamaño de la lista de tipos. Para las listas de valores, este método es ineficiente (por esta razón, `std::list` no define un `operador[]`). Sin embargo, en el caso de las listas de tipos, el tiempo se consume durante la compilación, y el tiempo de compilación es, en cierto sentido, "libre".

> En realidad, esto no es del todo cierto para grandes proyectos. Es posible, al menos en teoría, que la manipulación pesada de listas de tipos pueda ralentizar considerablemente el tiempo de compilación. De todos modos, un programa que contiene listas de tipos muy grandes consume velocidad de ejecución (en cuyo caso está dispuesto a aceptar compilaciones más lentas) o está demasiado acoplado, en cuyo caso una revisión de diseño estaría en orden.

## Buscar listas de tipos

¿Cómo buscarías en una lista de tipos un tipo dado? Intentemos implementar un algoritmo `IndexOf` que calcule el índice de un tipo en una lista de tipos. Si no se encuentra el tipo, el resultado será un valor no válido, digamos -1. El algoritmo es una búsqueda lineal clásica implementada recursivamente.

<kbd>IndexOf</kbd>

| Entradas                         | Salidas                                          |
| -------------------------------- | ------------------------------------------------ |
| Lista de tipos `TList`, tipo `T` | Valor constante interno en tiempo de compilación |

- Si `TList` es `NullType` Entonces
  - El valor es `-1`.
- Si no si la cabeza de `TList` es `T` Entonces
  - El valor es `0`.
- Si no Entonces
  - Calcule el resultado de `IndexOf` aplicado a la cola de `TList` y `T` en un valor temporal `temp`.
  - Si `temp` es `-1` Entonces
    - `value` es `-1`.
  - Si no Entonces
    - `value` es `1` más `temp`.

`IndexOf` es un algoritmo relativamente simple. Se presta especial atención para propagar el valor "no encontrado" (-1) al resultado. Necesitamos tres especializaciones, una para cada rama en el algoritmo. La última rama (cálculo del `value` de `temp`) es un cálculo numérico que llevamos con el operador condicional ?:. Aquí está la implementación:

```cpp
template <class TList, class T> struct IndexOf;
template <class T>
struct IndexOf<NullType, T> {
	enum { value = -1 };
};

template <class T, class Tail>
struct IndexOf<Typelist<T, Tail>, T> {
	enum { value = 0 };
};

template <class Head, class Tail, class T>
struct IndexOf<Typelist<Head, Tail>, T> {
private:
	enum { temp = IndexOf<Tail, T>::value };
public:
	enum { value = temp == -1 ? -1 : 1 + temp };
};
```

## Agregar a listas de tipos

Necesitamos un medio para agregar un tipo o una lista de tipos a una lista de tipos. Debido a que no es posible modificar una lista de tipos, como se discutió anteriormente, "retornaremos por valor" creando una nueva lista de tipos que contenga el resultado.

<kbd>Append</kbd>

| Entradas                                | Salidas                             |
| --------------------------------------- | ----------------------------------- |
| `Typelist` `TList`, type o typelist `T` | Definición de tipo interno `Result` |

- Si `TList` es `NullType` y `T` es `NullType` Entonces
  - `Result` es `NullType`.
- Si no si `TList` es `NullType` y `T` es un tipo único (no tipológico)
  - Entonces `Result` es una lista de tipos que tiene `T` como único elemento.
- Si no si `TList` es `NullType` y `T` es una lista de tipos Entonces
  - El resultado es `T` en sí.
- Si no si `List` no es null
  - Entonces `Result` es una lista de tipos que tiene `TList::Head` como cabecera y el resultado de agregar `T` a `TList::Tail` como cola.

Este algoritmo se asigna naturalmente al siguiente código:

```cpp
template <class TList, class T> struct Append;
template <> struct Append<NullType, NullType> {
	typedef NullType Result;
};

template <class T> struct Append<NullType, T> {
	typedef TYPELIST_1(T) Result;
};

template <class Head, class Tail>
struct Append<NullType, Typelist<Head, Tail> > {
	typedef Typelist<Head, Tail> Result;
};

template <class Head, class Tail, class T>
struct Append<Typelist<Head, Tail>, T> {
	typedef Typelist<Head,
	typename Append<Tail, T>::Result>
	Result;
};
```

Observe, de nuevo, cómo la última versión parcialmente especializada de `Append` crea una instancia de la plantilla `Append` de forma recursiva, pasándole el final de la lista y el tipo de anexo.

Ahora tenemos una operación unificada de `Append` para tipos únicos y listas de tipos. Por ejemplo, la declaración:

```cpp
typedef Append<SignedIntegrals, TYPELIST_3(float, double, long double)>::Result SignedTypes;
```

define una lista que contiene todos los tipos numéricos con signo en `C++`.

## Borrar un tipo de una lista de tipos

Ahora, para la operación opuesta, borrar un tipo de una lista de tipos, tenemos dos opciones: borrar solo la primera aparición o borrar todas las ocurrencias de un tipo dado.

Pensemos en eliminar solo la primera aparición.

<kbd>Erase</kbd>

| Entradas                         | Salidas                             |
| -------------------------------- | ----------------------------------- |
| Lista de tipos `TList`, tipo `T` | Definición de tipo interno `Result` |

- Si `TList` es `NullType` Entonces
  - `Result` es `NullType`.
- Si no si `T` es igual a `TList::Head` Entonces
  - `Result` es `TList::Tail`.
- Si no Entonces
  - `Result` es una lista de tipos que tiene `TList::Head` como cabeza y el resultado de aplicar `Erase` a `TList::Tail` y `T` como cola.

Así es como este algoritmo se asigna a `C++`.

```cpp
template <class TList, class T> struct Erase;

template <class T> // Specialization 1
struct Erase<NullType, T> {
	typedef NullType Result;
};

template <class T, class Tail> // Specialization 2
struct Erase<Typelist<T, Tail>, T> {
	typedef Tail Result;
};

template <class Head, class Tail, class T> // Specialization 3
struct Erase<Typelist<Head, Tail>, T> {
	typedef Typelist<Head,
	typename Erase<Tail, T>::Result>
	Result;
};
```

Como en el caso de `TypeAt`, no hay una versión predeterminada de la plantilla. Esto significa que puede instanciar `Erase` solo con ciertos tipos. Por ejemplo, `Erase<double, int>` produce un error en tiempo de compilación porque no hay coincidencia para ello. `Erase` necesita que su primer parámetro sea una lista de tipos.

Usando nuestra definición de `SignedTypes`, ahora podemos decir lo siguiente:

```cpp
// SomeSignedTypes contains the equivalent of
// TYPELIST_6(signed char, short int, int, long int,
// double, long double)
typedef Erase<SignedTypes, float>::Result SomeSignedTypes;
```

Veamos el algoritmo de borrado recursivo. La plantilla `EraseAll` borra todas las apariciones de un tipo en una lista de tipos. La implementación es similar a la de `Erase`, con una diferencia. Al detectar un tipo para borrar, el algoritmo no se detiene. `EraseAll` continúa buscando y eliminando coincidencias en la cola de la lista aplicándose recursivamente:

```cpp
template <class TList, class T> struct EraseAll;

template <class T>
struct EraseAll<NullType, T> {
	typedef NullType Result;
};

template <class T, class Tail>
struct EraseAll<Typelist<T, Tail>, T> {
	// Go all the way down the list removing the type
	typedef typename EraseAll<Tail, T>::Result Result;
};

template <class Head, class Tail, class T>
struct EraseAll<Typelist<Head, Tail>, T> {
	// Go all the way down the list removing the type
	typedef Typelist<Head,
	typename EraseAll<Tail, T>::Result>
	Result;
};
```

## Borrar duplicados

Una operación importante en las listas de tipos es borrar valores duplicados.

La necesidad es transformar una lista de tipos para que cada tipo aparezca solo una vez. Por ejemplo, de esto:

```cpp
TYPELIST_6(Widget, Button, Widget, TextField, ScrollBar, Button)
```

necesitamos obtener esto:

```cpp
TYPELIST_4(Widget, Button, TextField, ScrollBar)
```

Este procesamiento es un poco más complejo, pero, como puede suponer, podemos usar `Erase` para ayudar.

<kbd>NoDuplicates</kbd>

| Entradas               | Salidas                             |
| ---------------------- | ----------------------------------- |
| Lista de tipos `TList` | Definición de tipo interno `Result` |

- Si `TList` es `NullType` Entonces
  - `Result` es `NullType`.
- Si no Entonces
  - Aplique `NoDuplicates` a `TList::Tail`, obteniendo una lista de tipos temporal `L1`.
  - Aplicar `Erase` a `L1` y `TList::Head`. Obtenga `L2` como resultado.
  - `Result` es una lista de tipos cuya cabeza es `TList::Head` y cuya cola es `L2`.

Así es como este algoritmo se traduce en código:

```cpp
template <class TList> struct NoDuplicates;

template <> struct NoDuplicates<NullType> {
	typedef NullType Result;
};

template <class Head, class Tail>
struct NoDuplicates< Typelist<Head, Tail> > {
private:
	typedef typename NoDuplicates<Tail>::Result L1;
	typedef typename Erase<L1, Head>::Result L2;
public:
	typedef Typelist<Head, L2> Result;
};
```

¿Por qué `Erase` fue suficiente cuando `EraseAll` hubiera parecido apropiado? Queremos eliminar todos los duplicados para un tipo, ¿verdad? La respuesta es que `Erase` se aplica *después* de la recursión a `NoDuplicates`. Esto significa que borramos un tipo de una lista que ya no tiene duplicados, por lo que aparecerá como máximo una instancia del tipo que se va a borrar. Esta programación recursiva es bastante interesante.

## Sustitución de un elemento en una lista de tipos

A veces se necesita un reemplazo en lugar de una extracción. Como verá en la siguiente Sección [Listas de tipos de ordenamiento parciales](#listas-de-tipos-de-ordenamiento-parciales), reemplazar un tipo por otro es un componente importante para modismos más avanzados.

Necesitamos reemplazar el tipo `T` con el tipo `U` en una lista de tipos `TList`.

<kbd>Replace</kbd>

| Entradas                                                                            | Salidas                             |
| ----------------------------------------------------------------------------------- | ----------------------------------- |
| Lista de tipos `TList`, tipo `T` (para reemplazar) y tipo `U` (para reemplazar con) | Definición de tipo interno `Result` |

- Si `TList` es `NullType` Entonces
  - `Result` es `NullType`.
- Si no si el encabezado de la lista de tipos `TList` es `T` Entonces
  - `Result` es una lista de tipos con `U` como su encabezado y `TList::Tail` como su cola.
- Si no Entonces
  - `Result` es una lista de tipos con `TList::Head` como cabecera y el resultado de aplicar `Replace` a `TList`, `T` y `U` como cola.

Después de descubrir el algoritmo recursivo correcto, el código se escribe a sí mismo:

```cpp
template <class TList, class T, class U> struct Replace;

template <class T, class U>
struct Replace<NullType, T, U> {
	typedef NullType Result;
};

template <class T, class Tail, class U>
struct Replace<Typelist<T, Tail>, T, U> {
	typedef Typelist<U, Tail> Result;
};

template <class Head, class Tail, class T, class U>
struct Replace<Typelist<Head, Tail>, T, U> {
	typedef Typelist<Head,
	typename Replace<Tail, T, U>::Result>
	Result;
};
```

Obtenemos fácilmente el algoritmo `ReplaceAll` cambiando la segunda especialización por una que aplique recursivamente el algoritmo a `Tail`.

## Listas de tipos ordenadas parcialmente

Supongamos que queremos ordenar una lista de tipos por relación de herencia. Nos gustaría, por ejemplo, que los tipos derivados aparezcan antes que los tipos base. Por ejemplo, supongamos que tenemos una jerarquía de clases como la de la siguiente figura:

Si tenemos esta lista de tipos:

```cpp
TYPELIST_4(Widget, ScrollBar, Button, GraphicButton)
```

el desafío es transformarlo en:

```cpp
TYPELIST_4(ScrollBar, GraphicButton, Button, Widget)
```

Es decir, tenemos que traer los tipos más derivados al frente y dejar el orden de los tipos hermanos sin modificar.

Esto parece un ejercicio de valor intelectual solamente, pero hay importantes aplicaciones prácticas para ello. Escanear una lista de tipos ordenada con los tipos más derivados primero garantiza un recorrido ascendente de una jerarquía de clases. El motor de doble despacho en el Capítulo 11 aplica esta importante propiedad para averiguar información sobre tipos.

Al ordenar una colección, necesitamos una función de pedido. Ya tenemos un medio en tiempo de compilación para detectar relaciones de herencia, que se describe en detalle en el Capítulo 2. Recuerde que tenemos una práctica macro, `SUPERSUBCLASS(T, U)`, que se evalúa como `true` si `U` se deriva de `T`. Simplemente tenemos que combine el mecanismo de detección de herencia con listas de tipos.

No podemos utilizar un algoritmo de ordenación completo porque no tenemos una relación de ordenación total; no tenemos el equivalente del `operator<` para las clases. `SUPERSUBCLASS(T, U)` no puede ordenar dos clases de hermanos. Por lo tanto, utilizaremos un algoritmo personalizado que traerá las clases derivadas al frente y permitirá que otras clases permanezcan en las mismas posiciones relativas.

<kbd>DerivedToFront</kbd>

| Entradas               | Salidas                             |
| ---------------------- | ----------------------------------- |
| Lista de tipos `TList` | Definición de tipo interno `Result` |

- Si `TList` es `NullType` Entonces
  - `Result` es `NullType`.
- Si no Entonces
  - Encuentre el tipo más derivado de `TList::Head` en `TList::Tail`. Almacénelo en una variable temporal `TheMostDerived`.
  - Reemplace `TheMostDerived` en `TList::Tail` con `TList::Head`, obteniendo `L` como resultado.
  - Construya el resultado como una lista de tipos con `TheMostDerived` como encabezado y `L` como cola.

Cuando este algoritmo se aplica a una lista de tipos, los tipos derivados migrarán a la parte superior de la lista de tipos y los tipos base se desplazarán a la parte inferior.

Aquí falta una pieza: el algoritmo que encuentra el tipo más derivado de un tipo dado en una lista de tipos. Debido a que `SUPERSUBCLASS` produce un valor booleano en tiempo de compilación, encontraremos que la pequeña plantilla de clase `Select` (también presentada en el Capítulo 2) es útil. Recuerde que `Select` es una plantilla que selecciona uno de los dos tipos en función de una constante booleana en tiempo de compilación.

El algoritmo `MostDerived` acepta una lista de tipos y un tipo `Base` y retorna el tipo más derivado de `Base` en la lista de tipos (o posiblemente `Base` en sí, si no se encuentra ningún tipo derivado). Se parece a esto:

<kbd>MostDerived</kbd>

| Entradas                         | Salidas                             |
| -------------------------------- | ----------------------------------- |
| Lista de tipos `TList`, tipo `T` | Definición de tipo interno `Result` |

- Si `TList` es `NullType` Entonces
  - El resultado es `T`.
- Si no Entonces
  - Aplicar `MostDerived` a `TList::Tail` y `Base`. Obtener candidato.
  - Si `TList::Head` se deriva de `Candidate` Entonces
    - El resultado es `TList::Head`.
  - Si no Entonces
    - El resultado es `Candidate`

La implementación de `MostDerived` es la siguiente:

```cpp
template <class TList, class T> struct MostDerived;

template <class T>
struct MostDerived<NullType, T> {
	typedef T Result;
};

template <class Head, class Tail, class T>
struct MostDerived<Typelist<Head, Tail>, T> {
private:
	typedef typename MostDerived<Tail, T>::Result Candidate;
public:
	typedef typename Select<SUPERSUBCLASS(Candidate, Head), Head, Candidate>::Result Result;
};
```

El algoritmo `DerivedToFront` usa `MostDerived` como primitivo. Aquí está la implementación de `DerivedToFront`:

```cpp
template <class T> struct DerivedToFront;

template <>
struct DerivedToFront<NullType> {
	typedef NullType Result;
};

template <class Head, class Tail>
struct DerivedToFront< Typelist<Head, Tail> > {
private:
	typedef typename MostDerived<Tail, Head>::Result TheMostDerived;
	typedef typename Replace<Tail, TheMostDerived, Head>::Result L;
public:
	typedef Typelist<TheMostDerived, L> Result;
};
```

Esta compleja manipulación de listas de tipos tiene una fuerza considerable. La transformación `DerivedToFront` automatiza efectivamente el procesamiento de tipos que, de lo contrario, solo se puede realizar con mucha disciplina y atención. Mantenimiento automático de jerarquías de clases paralelas, ¿Alguien?

## Generación de clase con listas de tipos

Si, hasta ahora, encontró las listas de tipos interesantes, interesantes o simplemente feas, todavía no ha visto nada. Esta sección está dedicada a definir construcciones fundamentales para la generación de código con listas de tipos. Es decir, ya no escribimos código; en su lugar, ponemos el compilador a trabajar generando código para nosotros. Estas construcciones usan una de las construcciones más poderosas de `C++`, una característica que no tiene comparación con ningún otro lenguaje: *parámetros de plantilla de plantilla*.

Hasta ahora, la manipulación de la lista de tipos no ha producido código real; el procesamiento ha producido solo listas de tipos, tipos o constantes numéricas en tiempo de compilación (como fue el caso con `Length`). Veamos cómo generar un código real, es decir, cosas que dejan rastros en el código compilado.

Los objetos de la lista de tipos no tienen uso como son; están desprovistos de cualquier estado o funcionalidad de tiempo de ejecución. Una necesidad importante en la programación con listas de tipos es generar clases a partir de listas de tipos. Los programadores de aplicaciones a veces necesitan llenar una clase con código, ya sea firmas de funciones virtuales, declaraciones de datos o implementaciones de funciones, de manera dirigida por una lista de tipos. Intentaremos automatizar dichos procesos con listas de tipos.

Debido a que `C++` carece de iteraciones en tiempo de compilación o macros recursivas, la tarea de agregar algo de código para cada tipo en una lista de tipos es difícil. Puede utilizar la especialización de plantilla parcial de manera similar a los algoritmos descritos anteriormente, pero implementar esta solución en el código de usuario es torpe y complicado. Loki debería ser de ayuda con esta tarea.

### Generando jerarquías dispersas

Una potente plantilla de utilidad proporcionada por Loki facilita la creación de clases al aplicar cada tipo en una lista de tipos a una plantilla básica, proporcionada por el usuario. De esta forma, el proceso torpe de distribuir tipos en la lista de tipos al código de usuario se encapsula en la biblioteca; el usuario solo necesita definir una plantilla simple de un parámetro.

La plantilla de clase de biblioteca se llama `GenScatterHierarchy`. Aunque tiene una definición simple, `GenScatterHierarchy` tiene una potencia asombrosa bajo su capó, como verá pronto. Por ahora, veamos su definición.

> Esta es una de esas situaciones en las que presentar la idea antes de sus posibles aplicaciones (en lugar de una secuencia de solución de problemas) es más apropiado.

```cpp
template <class TList, template <class> class Unit>
class GenScatterHierarchy;

// GenScatterHierarchy specialization: Typelist to Unit
template <class T1, class T2, template <class> class Unit>
class GenScatterHierarchy<Typelist<T1, T2>, Unit>
	: public GenScatterHierarchy<T1, Unit>
	, public GenScatterHierarchy<T2, Unit> {
public:
	typedef Typelist<T1, T2> TList;
	typedef GenScatterHierarchy<T1, Unit> LeftBase;
	typedef GenScatterHierarchy<T2, Unit> RightBase;
};

// Pass an atomic type (non-typelist) to Unit
template <class AtomicType, template <class> class Unit>
class GenScatterHierarchy : public Unit<AtomicType> {
	typedef Unit<AtomicType> LeftBase;
};

// Do nothing for NullType
template <template <class> class Unit>
class GenScatterHierarchy<NullType, Unit> {
};
```

Los parámetros de la plantilla de plantilla funcionan de la manera esperada (consulte también el Capítulo 1). Pasa una `Unit` de clase de plantilla a `GenScatterHierarchy` como segundo argumento. Internamente, `GenScatterHierarchy` usa su unidad de parámetro de plantilla de plantilla como lo hubiera hecho con cualquier clase de plantilla regular con un parámetro de plantilla. El poder proviene de su capacidad, como usuario de `GenScatterHierarchy`, de transmitirle una plantilla escrita por usted.

¿Qué hace `GenScatterHierarchy`? Si su primer argumento de plantilla es un tipo atómico (a diferencia de una lista de tipos), `GenScatterHierarchy` pasa ese tipo a `Unit` y hereda de la clase resultante `Unit<T>`. Si el primer argumento de plantilla de `GenScatterHierarchy` es una lista de tipos `TList`, `GenScatterHierarchy` recurre a `GenScatterHierarchy<TList::Head, Unit>` y `GenScatterHierarchy<TList::Tail, Unit>`, y hereda ambos. `GenScatterHierarchy<NullType, Unit>` es una clase vacía.

En última instancia, una instanciación de `GenScatterHierarchy` termina heredando `Unit` instanciada con cada tipo en la lista de tipos. Por ejemplo, considere este código:

```cpp
template <class T>
struct Holder {
	T value_;
};

typedef GenScatterHierarchy<TYPELIST_3(int, string, Widget), Holder> WidgetInfo;
```

La jerarquía de herencia generada por `WidgetInfo` se parece a la Figura 3.2. Llamamos a la jerarquía de clases en la Figura 3.2 dispersa, porque los tipos en la lista de tipos están dispersos en distintas clases de raíz. Esta es la esencia de GenScatteredHierarchy: genera una jerarquía de clases para usted al instanciar repetidamente una plantilla de clase que proporciona como modelo. Luego recopila todas las clases generadas en una clase de hoja única, en nuestro caso, WidgetInfo.

Como efecto de heredar `Holder<int>`, `Holder<string>` y `Holder<Widget>`, `WidgetInfo` tiene una variable miembro `value_` para cada tipo en la lista de tipos. La Figura 3.3 muestra un diseño binario probable de un objeto `WidgetInfo`. El diseño asume que las clases vacías como `GenScatterHierarchy<NullType, Holder>` están optimizadas y no ocupan ningún almacenamiento en el objeto compuesto.

Puedes hacer cosas interesantes con los objetos `WidgetInfo`. Puede, por ejemplo, acceder a la `string` almacenada en un objeto WidgetInfo escribiendo:

```cpp
WidgetInfo obj;
string name = (static_cast<Holder<string>&>(obj)).value_;
```

La conversión explícita es necesaria para eliminar la ambigüedad del nombre de la variable miembro `value_`. De lo contrario, el compilador se confunde con respecto a qué `valor_` miembro se está refiriendo.

Este reparto es bastante feo, así que tratemos de hacer que `GenScatterHierarchy` sea más fácil de usar al proporcionar algunas funciones de acceso útiles. Por ejemplo, una buena función miembro accedería a un miembro por su tipo. Esto es bastante facil.

```cpp
// Refer to HierarchyGenerators.h for FieldTraits' definition
template <class T, class H>
typename Private::FieldTraits<H>::Rebind<T>::Result&
Field(H& obj) {
	return obj;
}
```

`Field` se basa en la conversión implícita derivada a base. Si llama a `Field<Widget>` (`obj`) (`obj` es de tipo `WidgetInfo`), el compilador descubre que `Holder<Widget>` es una clase base de `WidgetInfo` y simplemente devuelve una referencia a esa parte del objeto compuesto.

¿Por qué es `Field` una función de nivel de espacio de nombres y no una función miembro? Bueno, una programación tan genérica debe jugar con mucho cuidado con los nombres. Imagine, por ejemplo, que `Unit` misma define un símbolo con el nombre `Field`. Si `GenScatterHierarchy` definiera una función miembro `Field`, habría enmascarado al miembro `Field` de `Unit`. Esta sería una fuente importante de molestia para el usuario.

Hay una fuente principal de molestia con `Field`: no puede usarla cuando tiene tipos duplicados en sus listas de tipos. Considere esta definición ligeramente modificada de `WidgetInfo`:

```cpp
typedef GenScatterHierarchy<TYPELIST_4(int, int, string, Widget), Value> WidgetInfo;
```

Ahora `WidgetInfo` tiene dos miembros `value_` de tipo `int`. Si intenta llamar a `Field<int>` para un objeto `WidgetInfo`, el compilador se queja de una ambigüedad. No hay una manera fácil de resolver la ambigüedad, porque `WidgetInfo` termina heredando `Holder<int>` dos veces a través de diferentes rutas, como se muestra en la Figura 3.4.

Necesitamos un medio para seleccionar campos en una instanciación de `GenScatterHierarchy` por *índice posicional*, no por nombre de tipo. Si pudiera referirse a cada uno de los dos campos de tipo `int` por su posición en la lista de tipos (es decir, como `Field<0>(obj)` y `Field<1>(obj)`), se libraría de la ambigüedad.

Implementemos una función de acceso de campo basada en índices. Tenemos que enviar en tiempo de compilación entre el índice de campo cero, que accede al encabezado de la lista de tipos, y no cero, que accede a la cola de la lista de tipos. El envío es fácil con la ayuda de la pequeña plantilla `Int2Type` definida en el Capítulo 2. Recuerde que `Int2Type` simplemente transforma cada integral constante distinta en un tipo distinto. Además, utilizamos `Type2Type` para transportar el tipo de resultado de manera adecuada, como se muestra a continuación.

```cpp
template <class H, typename R>
inline R& FieldHelper(H& obj, Type2Type<R>, Int2Type<0>) {
	typename H::LeftBase& subobj = obj;
	return subobj;
}

template <class H, typename R, int i>
inline R& FieldHelper(H& obj, Type2Type<R> tt, Int2Type<i>) {
	typename H::RightBase& subobj = obj;
	return FieldHelper(subobj, tt, Int2Type<i- 1>());
}

//Refer to HierarchyGenerators.h for FieldTraits' definition
template <int i, class H>
typename Private::FieldTraits<H>::At<i>::Result&
Field(H& obj) {
	typedef typename Private::FieldTraits<H>::At<i>::Result Result;
	return FieldHelper(obj, Type2Type<Result>(), Int2type<i>());
}
```

Lleva un tiempo descubrir cómo escribir una implementación de este tipo, pero afortunadamente explicarlo es bastante fácil. Dos funciones sobrecargadas llamadas `FieldHelper` hacen el trabajo real. El primero acepta un parámetro de tipo `Int2Type<0>`, y el segundo es una plantilla que acepta `Int2Type<any integer>`. En consecuencia, la primera sobrecarga devuelve el valor correspondiente a la `Unit<T1>&`, y la otra devuelve el tipo en el índice especificado en la lista de tipos. `Field` utiliza una plantilla auxiliar `FieldTraits` para determinar qué tipo debe devolver. `Field` pasa ese tipo a `FieldHelper` a través de `Type2Type`.
